import { Router } from 'express';
import { query } from '../db';

const router = Router();

router.get('/overview', async (req, res) => {
    try {
        const productsCount = await query('SELECT COUNT(*) FROM products');
        const stockValue = await query(`
      SELECT SUM(p.cost * s.quantity) as total_value
      FROM stock_snapshots s
      JOIN products p ON s.product_id = p.id
      WHERE s.captured_at = (
        SELECT MAX(captured_at) FROM stock_snapshots WHERE product_id = s.product_id
      )
    `);
        const salesToday = await query(`
      SELECT SUM(total_amount) as total_sales
      FROM daily_sales
      WHERE sale_date = CURRENT_DATE
    `);

        res.json({
            totalProducts: parseInt(productsCount.rows[0].count),
            stockValue: parseFloat(stockValue.rows[0].total_value || '0'),
            salesToday: parseFloat(salesToday.rows[0].total_sales || '0'),
            alertsCount: 0 // Will be updated by frontend fetching /alerts
        });
    } catch (error) {
        console.error('Error fetching overview:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.get('/alerts', async (req, res) => {
    // For now, generate alerts on the fly based on stock
    try {
        const lowStock = await query(`
      SELECT p.name, s.quantity
      FROM stock_snapshots s
      JOIN products p ON s.product_id = p.id
      WHERE s.captured_at = (
        SELECT MAX(captured_at) FROM stock_snapshots WHERE product_id = s.product_id
      )
      AND s.quantity < 10
    `);

        const alerts = lowStock.rows.map((row: any, index: number) => ({
            id: `stock-${index}`,
            type: 'ruptura',
            message: `Baixo estoque: ${row.name} (${row.quantity} un.)`,
            severity: 'high',
            productName: row.name,
            stock: row.quantity,
            expiry: null
        }));

        // Validity Alerts
        const validity = await query(`
            SELECT id, name, next_expiry_date, 
            (next_expiry_date - CURRENT_DATE) as days_until_expiry
            FROM products 
            WHERE next_expiry_date IS NOT NULL 
            AND next_expiry_date <= CURRENT_DATE + INTERVAL '30 days'
            ORDER BY next_expiry_date ASC
        `);

        const validityAlerts = validity.rows.map((row: any, index: number) => {
            const days = row.days_until_expiry;
            let severity = 'low';
            if (days <= 7) severity = 'high';
            else if (days <= 15) severity = 'medium';

            return {
                id: `validity-${index}`,
                type: 'validade',
                message: `Vence em ${days} dias: ${row.name}`,
                severity: severity,
                productName: row.name,
                stock: 0, // We could fetch stock here too if needed
                expiry: `${days} dias`
            };
        });

        res.json([...alerts, ...validityAlerts]);


    } catch (error) {
        console.error('Error fetching alerts:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.get('/ia-summary', (req, res) => {
    // In a real scenario, this would fetch the latest summary generated by Mangaba AI from the DB
    res.json({
        summary: "Sistema operando normalmente. Dados sendo processados pelo Mangaba AI.",
        recommendations: []
    });
});

router.get('/products', async (req, res) => {
    try {
        const result = await query(`
            SELECT p.*, s.quantity as stock
            FROM products p
            LEFT JOIN (
                SELECT product_id, quantity
                FROM stock_snapshots s1
                WHERE captured_at = (
                    SELECT MAX(captured_at) 
                    FROM stock_snapshots s2 
                    WHERE s2.product_id = s1.product_id
                )
            ) s ON p.id = s.product_id
            ORDER BY p.name ASC
        `);
        res.json(result.rows);
    } catch (error) {
        console.error('Error fetching products:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.get('/products/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const product = await query('SELECT * FROM products WHERE id = $1', [id]);

        if (product.rows.length === 0) {
            return res.status(404).json({ error: 'Product not found' });
        }

        const stock = await query(`
      SELECT quantity FROM stock_snapshots 
      WHERE product_id = $1 
      ORDER BY captured_at DESC LIMIT 1
    `, [id]);

        res.json({
            ...product.rows[0],
            stock: stock.rows[0]?.quantity || 0
        });
    } catch (error) {
        console.error('Error fetching product:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.get('/insights', async (req, res) => {
    try {
        const result = await query(`
            SELECT * FROM analysis_results 
            ORDER BY created_at DESC 
            LIMIT 1
        `);

        if (result.rows.length === 0) {
            return res.json(null);
        }

        res.json(result.rows[0]);
    } catch (error) {
        console.error('Error fetching insights:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

router.get('/predictions', async (req, res) => {
    try {
        const result = await query(`
            SELECT 
                pr.*,
                p.name as product_name,
                p.category,
                p.price,
                p.cost
            FROM predictions pr
            JOIN products p ON pr.product_id = p.id
            WHERE pr.status != 'ok'
            ORDER BY pr.confidence_score DESC
        `);
        res.json(result.rows);
    } catch (error) {
        console.error('Error fetching predictions:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

export default router;
